// This file is @generated by prost-build.
//
// *** GENERATED CODE - DO NOT EDIT ***
//
// This file was generated from bh_spirom_protobufs/fw_table.proto using prost-build.
//
// To regenerate this file if the .proto file changes:
// 1. Install protoc: `sudo apt-get install protobuf-compiler`
// 2. Ensure prost-build dependency is available
// 3. Run: `cargo run --manifest-path ../../../Cargo.toml --bin generate_protobuf`
// 4. Or manually using prost-build:
//    ```rust
//    use prost_build::Config;
//    let mut config = Config::new();
//    config.out_dir("src/generated");
//    config.type_attribute(".", "#[derive(serde::Serialize, serde::Deserialize)]");
//    config.compile_protos(&["bh_spirom_protobufs/fw_table.proto"], &["bh_spirom_protobufs/"]).unwrap();
//    ```
// 5. Move generated _.rs file to fw_table.rs
//
// Original protobuf file: bh_spirom_protobufs/fw_table.proto
// Generated using protoc version: 3.21.12
// Generated using prost-build version: 0.13.5
// Generated on: 2025-07-03
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct FwTable {
    #[prost(uint32, tag = "1")]
    pub fw_bundle_version: u32,
    #[prost(message, optional, tag = "2")]
    pub chip_limits: ::core::option::Option<fw_table::ChipLimits>,
    #[prost(message, optional, tag = "3")]
    pub feature_enable: ::core::option::Option<fw_table::FeatureEnable>,
    #[prost(message, optional, tag = "4")]
    pub fan_table: ::core::option::Option<fw_table::FanTable>,
    #[prost(message, optional, tag = "5")]
    pub dram_table: ::core::option::Option<fw_table::DramTable>,
    #[prost(message, optional, tag = "6")]
    pub chip_harvesting_table: ::core::option::Option<fw_table::ChipHarvestingTable>,
    #[prost(message, optional, tag = "7")]
    pub pci0_property_table: ::core::option::Option<fw_table::PciPropertyTable>,
    #[prost(message, optional, tag = "8")]
    pub pci1_property_table: ::core::option::Option<fw_table::PciPropertyTable>,
    #[prost(message, optional, tag = "9")]
    pub eth_property_table: ::core::option::Option<fw_table::EthPropertyTable>,
}
/// Nested message and enum types in `FwTable`.
pub mod fw_table {
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Clone, Copy, PartialEq, ::prost::Message)]
    pub struct ChipLimits {
        #[prost(uint32, tag = "1")]
        pub asic_fmax: u32,
        #[prost(uint32, tag = "2")]
        pub vdd_max: u32,
        #[prost(uint32, tag = "3")]
        pub vdd_min: u32,
        #[prost(uint32, tag = "4")]
        pub voltage_margin: u32,
        #[prost(uint32, tag = "5")]
        pub tdp_limit: u32,
        #[prost(uint32, tag = "6")]
        pub tdc_limit: u32,
        #[prost(uint32, tag = "7")]
        pub thm_limit: u32,
        #[prost(uint32, tag = "8")]
        pub tdc_fast_limit: u32,
        #[prost(uint32, tag = "9")]
        pub therm_trip_l1_limit: u32,
        #[prost(uint32, tag = "10")]
        pub bus_peak_limit: u32,
        #[prost(uint32, tag = "11")]
        pub frequency_margin: u32,
        #[prost(uint32, tag = "12")]
        pub asic_fmin: u32,
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Clone, Copy, PartialEq, ::prost::Message)]
    pub struct FeatureEnable {
        #[prost(bool, tag = "1")]
        pub cg_en: bool,
        #[prost(bool, tag = "2")]
        pub noc_translation_en: bool,
        #[prost(bool, tag = "3")]
        pub ddr_train_en: bool,
        #[prost(bool, tag = "4")]
        pub aiclk_ppm_en: bool,
        #[prost(bool, tag = "5")]
        pub watchdog_en: bool,
        #[prost(bool, tag = "6")]
        pub smbus_en: bool,
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Clone, Copy, PartialEq, ::prost::Message)]
    pub struct FanTable {
        #[prost(uint32, tag = "1")]
        pub fan_table_point_x1: u32,
        #[prost(uint32, tag = "2")]
        pub fan_table_point_x2: u32,
        #[prost(uint32, tag = "3")]
        pub fan_table_point_y1: u32,
        #[prost(uint32, tag = "4")]
        pub fan_table_point_y2: u32,
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Clone, Copy, PartialEq, ::prost::Message)]
    pub struct DramTable {
        #[prost(uint32, tag = "1")]
        pub dram_mask: u32,
        #[prost(bool, tag = "2")]
        pub dram_mask_en: bool,
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Clone, Copy, PartialEq, ::prost::Message)]
    pub struct ChipHarvestingTable {
        #[prost(uint32, tag = "1")]
        pub soft_harvesting_en: u32,
        #[prost(uint32, tag = "2")]
        pub soft_harvesting: u32,
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Clone, Copy, PartialEq, ::prost::Message)]
    pub struct PciPropertyTable {
        #[prost(uint32, tag = "1")]
        pub max_pcie_speed: u32,
        #[prost(uint32, tag = "3")]
        pub pcie_bar0_size: u32,
        #[prost(uint32, tag = "4")]
        pub pcie_bar2_size: u32,
        #[prost(uint32, tag = "5")]
        pub pcie_bar4_size: u32,
        #[prost(enumeration = "pci_property_table::PcieMode", tag = "6")]
        pub pcie_mode: i32,
        #[prost(uint32, tag = "7")]
        pub num_serdes: u32,
    }
    /// Nested message and enum types in `PciPropertyTable`.
    pub mod pci_property_table {
        #[derive(serde::Serialize, serde::Deserialize)]
        #[derive(
            Clone,
            Copy,
            Debug,
            PartialEq,
            Eq,
            Hash,
            PartialOrd,
            Ord,
            ::prost::Enumeration
        )]
        #[repr(i32)]
        pub enum PcieMode {
            Disabled = 0,
            Ep = 1,
            Rp = 2,
        }
        impl PcieMode {
            /// String value of the enum field names used in the ProtoBuf definition.
            ///
            /// The values are not transformed in any way and thus are considered stable
            /// (if the ProtoBuf definition does not change) and safe for programmatic use.
            pub fn as_str_name(&self) -> &'static str {
                match self {
                    Self::Disabled => "DISABLED",
                    Self::Ep => "EP",
                    Self::Rp => "RP",
                }
            }
            /// Creates an enum from field names used in the ProtoBuf definition.
            pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                match value {
                    "DISABLED" => Some(Self::Disabled),
                    "EP" => Some(Self::Ep),
                    "RP" => Some(Self::Rp),
                    _ => None,
                }
            }
        }
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Clone, Copy, PartialEq, ::prost::Message)]
    pub struct EthPropertyTable {
        #[prost(uint32, tag = "1")]
        pub eth_disable_mask: u32,
        #[prost(bool, tag = "2")]
        pub eth_disable_mask_en: bool,
    }
}
